\documentclass[aspectratio=169, table]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{listings} 
\usepackage[strings]{underscore}
\usepackage{caption}
\usepackage{float}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows.meta, trees, positioning}


\renewcommand{\lstlistingname}{} 

\makeatletter
\def\input@path{{../../themes/Pradita}}
\makeatother

\usetheme{Pradita}

\subtitle{NoSQL with MongoDB}

\title{Session-02:\\\LARGE{CRUD and Modeling\\in MongoDB}
%\vspace{5pt}
}
\date[Serial]{\scriptsize {PRU/SPMI/FR-BM-18/0222}}
\author[Pradita]{\small{\textbf{Alfa Yohannis}}}


% Define Python language style for listings
\lstdefinestyle{PythonStyle}{
    language=Python,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    numbers=left,
    numberstyle=\tiny\color{gray},
    backgroundcolor=\color{lightgray!10},
    tabsize=2,
    captionpos=b
}

\lstdefinelanguage{bash} {
	keywords={},
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={},
	ndkeywordstyle=\color{purple}\bfseries,
	sensitive=true,
	numbers=left,
	numberstyle=\tiny\color{gray},
	breaklines=true,
	frame=lines,
	backgroundcolor=\color{lightgray!10},
	tabsize=2,
	comment=[l]{\#},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{gray}\ttfamily,
	stringstyle=\color{purple}\ttfamily,
	showstringspaces=false,
	morestring=[s]{"}{"}
}

\begin{document}

\frame{\titlepage}

% Add table of contents slide
\begin{frame}[fragile]{Contents}
\vspace{15pt}
\begin{columns}[t]
\begin{column}{.4\textwidth}
\tableofcontents[sections={1-4}]
\end{column}
\begin{column}{.6\textwidth}
\tableofcontents[sections={5-7}]
\end{column}
\end{columns}
\end{frame}

\section{Create}

\begin{frame}[fragile]{Insert One in mongosh}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.48\textwidth}
    \begin{itemize}
      \item Use \texttt{insertOne} to add a single document.
      \item Collection auto-created if not present.
      \item Each document gets an autogenerated \texttt{\_id}.
      \item Uses Indonesian field names for consistency.
    \end{itemize}
  \end{column}

  \begin{column}{0.52\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# Open MongoDB shell
mongosh
use toko_online

db.produk.insertOne({
  nama: "Laptop Pro X",
  harga: 18500000,
  kategori: "Elektronik",
  stok: 12
})

db.produk.find()
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Insert One in Python}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.4\textwidth}
    \begin{itemize}
      \item Python uses \texttt{insert_one()} from PyMongo.
      \item Targets database \texttt{toko\_online}.
      \item Indonesian keys kept consistent.
      \item Returns \texttt{inserted\_id} for tracking.
    \end{itemize}
  \end{column}

  \begin{column}{0.55\textwidth}
\begin{lstlisting}[style=PythonStyle,
basicstyle=\ttfamily\scriptsize]
from pymongo import MongoClient

client = MongoClient()
db = client["toko_online"]
produk = db["produk"]

hasil = produk.insert_one({
    "nama": "Mouse Wireless",
    "harga": 250000,
    "kategori": "Aksesoris",
    "stok": 50
})

print("Dokumen ditambahkan:",
      hasil.inserted_id)
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}



\begin{frame}[fragile]{Insert Many in mongosh}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.3\textwidth}
    \begin{itemize}
      \item Use \texttt{insertMany} to add multiple documents.
      \item More efficient than repeated \texttt{insertOne}.
      \item Ideal for seeding or batch data insertion.
      \item Indonesian field names kept consistent.
    \end{itemize}
  \end{column}

  \begin{column}{0.65\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
db.produk.insertMany([
  { nama: "Power Bank 20000mAh",
    harga: 350000, kategori: "Aksesoris", stok: 30 },
  { nama: "Monitor 27 inch",
    harga: 3200000, kategori: "Elektronik", stok: 8 },
  { nama: "Headset Gaming",
    harga: 850000, kategori: "Audio", stok: 20 }
])

db.produk.find()
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Insert Many in Python}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.3\textwidth}
    \begin{itemize}
      \item Python uses \texttt{insert_many()} for batch insert.
      \item Returns a list of \texttt{inserted\_ids}.
      \item Helpful for initial data loading.
      \item Uses Indonesian keys for consistency.
    \end{itemize}
  \end{column}

  \begin{column}{0.65\textwidth}
\begin{lstlisting}[style=PythonStyle,
basicstyle=\ttfamily\scriptsize]
from pymongo import MongoClient

client = MongoClient("mongodb://localhost:27017/")
db = client["toko_online"]
produk = db["produk"]

hasil = produk.insert_many([
    { "nama": "USB Hub 4 Port", "harga": 120000, "stok": 40 },
    { "nama": "Webcam HD", "harga": 450000, "stok": 15 },
    { "nama": "Portable SSD 1TB", "harga": 1450000, "stok": 10 }
])

print("ID dokumen:")
for _id in hasil.inserted_ids:
    print("-", _id)
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}


\section{Read}

\begin{frame}[fragile]{Basic Queries in mongosh}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.4\textwidth}
    \begin{itemize}
      \item \texttt{find()} retrieves documents from a collection.
      \item Without arguments, it returns all documents.
      \item Queries use JSON-like syntax.
      \item Supports conditions such as equality and comparison.
    \end{itemize}
  \end{column}

  \begin{column}{0.55\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# Show all documents
db.produk.find()

# Filter by category
db.produk.find({ kategori: "Elektronik" })

# Price greater than 1 million
db.produk.find({
  harga: { $gt: 1000000 }
})
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Basic Queries in Python}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.3\textwidth}
    \begin{itemize}
      \item Python uses \texttt{find()} from PyMongo.
      \item Each result is iterated as a document (dict).
      \item Query filters using the keys and values.
      \item Demonstrates full retrieval and conditional queries.
    \end{itemize}
  \end{column}

  \begin{column}{0.65\textwidth}
\begin{lstlisting}[style=PythonStyle,
basicstyle=\ttfamily\scriptsize]
from pymongo import MongoClient

client = MongoClient()
db = client["toko_online"]
produk = db["produk"]

# All documents
for p in produk.find():
    print(p)

# Category Elektronik
for p in produk.find({"kategori": "Elektronik"}):
    print(p)

# Price > 1,000,000
for p in produk.find({
    "harga": {"$gt": 1_000_000}
}):
    print(p)
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Projection in mongosh}
\vspace{20pt}
\begin{columns}[T]
  % Wider code column
  \begin{column}{0.40\textwidth}
    \begin{itemize}
      \item Projection limits fields in output.
      \item Useful for performance and clarity.
      \item Can include or exclude specific fields.
      \item Often used to hide \texttt{\_id}.
    \end{itemize}
  \end{column}

  \begin{column}{0.60\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# Show only name and price
db.produk.find(
  { kategori: "Elektronik" },
  { nama: 1, harga: 1 }
)

# Hide _id
db.produk.find(
  { kategori: "Elektronik" },
  { _id: 0, nama: 1, harga: 1 }
)
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Projection in Python}
\vspace{20pt}
\begin{columns}[T]
  % Wider code column
  \begin{column}{0.40\textwidth}
    \begin{itemize}
      \item PyMongo supports projection using dicts.
      \item Include fields with \texttt{1}, exclude with \texttt{0}.
      \item Useful for controlling API output.
      \item Common for filtering large documents.
    \end{itemize}
  \end{column}

  \begin{column}{0.60\textwidth}
\begin{lstlisting}[style=PythonStyle,
basicstyle=\ttfamily\scriptsize]
from pymongo import MongoClient

client = MongoClient()
db = client["toko_online"]
produk = db["produk"]

# Show only 'nama' and 'harga'
cursor = produk.find(
    {"kategori": "Elektronik"},
    {"nama": 1, "harga": 1}
)
for p in cursor:
    print(p)

# Hide _id
cursor = produk.find(
    {"kategori": "Elektronik"},
    {"_id": 0, "nama": 1, "harga": 1}
)
for p in cursor:
    print(p)
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Sorting in mongosh}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.40\textwidth}
    \begin{itemize}
      \item Sorting arranges results by specific fields.
      \item Use \texttt{1} for ascending and \texttt{-1} for descending.
      \item Works on any numeric or string field.
      \item Often applied after \texttt{find()}.
    \end{itemize}
  \end{column}

  \begin{column}{0.60\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# Sort by lowest price
db.produk.find().sort({ harga: 1 })

# Sort by highest stock
db.produk.find().sort({ stok: -1 })
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Sorting in Python}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.40\textwidth}
    \begin{itemize}
      \item Python uses \texttt{sort()} chained to \texttt{find()}.
      \item Uses constants: \texttt{ASCENDING}, \texttt{DESCENDING}.
      \item Supports multi-field sorting when needed.
      \item Useful for ordered API outputs.
    \end{itemize}
  \end{column}

  \begin{column}{0.60\textwidth}
\begin{lstlisting}[style=PythonStyle,
basicstyle=\ttfamily\scriptsize]
from pymongo import ASCENDING, DESCENDING

# Price ascending
for p in produk.find().sort("harga", ASCENDING):
    print(p)

# Stock descending
for p in produk.find().sort("stok", DESCENDING):
    print(p)
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Pagination in mongosh}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.40\textwidth}
    \begin{itemize}
      \item Pagination uses \texttt{skip()} and \texttt{limit()}.
      \item Useful for web views with many documents.
      \item Often combined with sorting for stable ordering.
      \item Ideal for small–medium datasets.
    \end{itemize}
  \end{column}

  \begin{column}{0.60\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# First 5 documents
db.produk.find().limit(5)

# Page 2: skip 5, take 5
db.produk.find().skip(5).limit(5)

# With sorting
db.produk.find()
  .sort({ harga: 1 })
  .skip(10).limit(10)
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Pagination in Python}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.40\textwidth}
    \begin{itemize}
      \item Python supports \texttt{skip()} and \texttt{limit()}.
      \item Each call returns a cursor for iteration.
      \item Sorting can be applied before paging.
      \item Useful for building product lists or dashboards.
    \end{itemize}
  \end{column}

  \begin{column}{0.60\textwidth}
\begin{lstlisting}[style=PythonStyle,
basicstyle=\ttfamily\scriptsize]
# First page: 5 docs
page1 = produk.find().limit(5)
for p in page1:
    print(p)

# Second page
page2 = produk.find().skip(5).limit(5)
for p in page2:
    print(p)

# With sorting
page_sorted = (produk.find()
    .sort("harga", 1)
    .skip(2).limit(2))
for p in page_sorted:
    print(p)
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}

\section{Update}

\begin{frame}[fragile]{Update One in mongosh}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.40\textwidth}
    \begin{itemize}
      \item \texttt{updateOne()} updates only the first matching document.
      \item Uses operators such as \texttt{\$set} and \texttt{\$inc}.
      \item Ideal for targeted updates on specific products.
      \item MongoDB returns matched and modified counts.
    \end{itemize}
  \end{column}

  \begin{column}{0.60\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# Update price
db.produk.updateOne(
  { nama: "Laptop Pro X" },
  { $set: { harga: 17900000 } }
)

# Increase stock
db.produk.updateOne(
  { nama: "Laptop Pro X" },
  { $inc: { stok: 5 } }
)

# Example result
{
  acknowledged: true,
  matchedCount: 1,
  modifiedCount: 1
}
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Update One in Python}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.40\textwidth}
    \begin{itemize}
      \item PyMongo provides \texttt{update_one()} for one-document updates.
      \item Supports \texttt{\$set}, \texttt{\$inc}, and other operators.
      \item Returned object includes match/modify info.
      \item Useful for precise item modifications.
    \end{itemize}
  \end{column}

  \begin{column}{0.60\textwidth}
\begin{lstlisting}[style=PythonStyle,
basicstyle=\ttfamily\scriptsize]
from pymongo import MongoClient

client = MongoClient()
db = client["toko_online"]
produk = db["produk"]

# Update price
hasil_harga = produk.update_one(
    {"nama": "Laptop Pro X"},
    {"$set": {"harga": 17_900_000}}
)
print("matched:", hasil_harga.matched_count)
print("modified:", hasil_harga.modified_count)

# Increase stock
hasil_stok = produk.update_one(
    {"nama": "Laptop Pro X"},
    {"$inc": {"stok": 5}}
)
print("matched:", hasil_stok.matched_count)
print("modified:", hasil_stok.modified_count)
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]{Update Operators in mongosh — Part 1}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.42\textwidth}
    \begin{itemize}
      \item MongoDB supports many update operators.
      \item \texttt{\$set}: replace or add fields.
      \item \texttt{\$inc}: increase/decrease numeric values.
      \item \texttt{\$push}: append to an array.
      \item Used for granular updates.
    \end{itemize}
  \end{column}

  \begin{column}{0.58\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# $set
db.produk.updateOne(
  { nama: "Mouse Wireless" },
  { $set: { harga: 275000, warna: "Hitam" } }
)

# $inc
db.produk.updateOne(
  { nama: "Portable SSD 1TB" },
  { $inc: { stok: -2 } }
)

# $push
db.produk.updateOne(
  { nama: "Headset Gaming" },
  { $push: { ulasan: "Suaranya bagus!" } }
)
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Update Operators in mongosh — Part 2}
\vspace{20pt}
\begin{columns}[T]
  \begin{column}{0.42\textwidth}
    \begin{itemize}
      \item \texttt{\$addToSet}: add to array without duplicates.
      \item \texttt{\$unset}: remove a field.
      \item \texttt{\$mul}: multiply numeric values.
      \item Useful for bulk value adjustments.
      \item Avoids rewriting entire documents.
    \end{itemize}
  \end{column}

  \begin{column}{0.58\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# $addToSet
db.produk.updateOne(
  { nama: "Headset Gaming" },
  { $addToSet: { tag: "gaming" } }
)

# $unset
db.produk.updateOne(
  { nama: "Webcam HD" },
  { $unset: { promo: "" } }
)

# $mul
db.produk.updateOne(
  { nama: "Monitor 27 inch" },
  { $mul: { harga: 0.95 } }
)
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]{Update Operators in Python}
\vspace{20pt}
\begin{columns}[T]

  \begin{column}{0.50\textwidth}
\begin{lstlisting}[style=PythonStyle,basicstyle=\ttfamily\scriptsize]
from pymongo import MongoClient

client = MongoClient()
db = client["toko_online"]
produk = db["produk"]

def print_hasil(header, hasil):
    print("#", header)
    print(" matched:", hasil.matched_count)
    print(" modified:", hasil.modified_count)

# $set
hasil = produk.update_one(
    {"nama": "Mouse Wireless"},
    {"$set": {"harga": 275000, "warna": "Hitam"}}
)
print_hasil("$set", hasil)

\end{lstlisting}
  \end{column}

  \begin{column}{0.50\textwidth}
\begin{lstlisting}[style=PythonStyle,basicstyle=\ttfamily\scriptsize, firstnumber=18]
# $addToSet
hasil = produk.update_one(
    {"nama": "Headset Gaming"},
    {"$addToSet": {"tag": "gaming"}}
)
print_hasil("$addToSet", hasil)

# $unset
hasil = produk.update_one(
    {"nama": "Webcam HD"},
    {"$unset": {"promo": ""}}
)
print_hasil("$unset", hasil)

# $mul
hasil = produk.update_one(
    {"nama": "Monitor 27 inch"},
    {"$mul": {"harga": 0.95}}
)
print_hasil("$mul", hasil)
\end{lstlisting}
  \end{column}

\end{columns}
\end{frame}

\section{Delete}

\begin{frame}[fragile]{Delete One in mongosh}
\vspace{20pt}
\begin{columns}[T]

  \begin{column}{0.40\textwidth}
    \begin{itemize}
      \item \texttt{deleteOne()} removes the first matching document.
      \item Uses a filter to determine which item is deleted.
      \item Only one document is affected even if many match.
      \item Operation is permanent and irreversible.
    \end{itemize}
  \end{column}

  \begin{column}{0.60\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# Delete by name
db.produk.deleteOne({ nama: "Mouse Wireless" })

# Delete product with zero stock
db.produk.deleteOne({ stok: 0 })

{
  acknowledged: true,
  deletedCount: 1
}
\end{lstlisting}
  \end{column}

\end{columns}
\end{frame}

\begin{frame}[fragile]{Delete One in Python}
\vspace{20pt}
\begin{columns}[T]

  \begin{column}{0.40\textwidth}
    \begin{itemize}
      \item Python uses \texttt{delete_one()} for single-document deletion.
      \item Returns \texttt{deleted\_count}.
      \item Filter must be precise to avoid unintended deletion.
      \item Suitable for safe record removal in applications.
    \end{itemize}
  \end{column}

  \begin{column}{0.60\textwidth}
\begin{lstlisting}[style=PythonStyle,
basicstyle=\ttfamily\scriptsize]
from pymongo import MongoClient

client = MongoClient()
db = client["toko_online"]
produk = db["produk"]

# Delete by name
hasil = produk.delete_one({"nama": "Mouse Wireless"})
print("Terhapus:", hasil.deleted_count)

# Delete product with stock 0
hasil2 = produk.delete_one({"stok": 0})
print("Terhapus:", hasil2.deleted_count)
\end{lstlisting}
  \end{column}

\end{columns}
\end{frame}

\begin{frame}[fragile]{Delete Many in mongosh}
\vspace{20pt}
\begin{columns}[T]

  \begin{column}{0.40\textwidth}
    \begin{itemize}
      \item \texttt{deleteMany()} removes all documents matching a filter.
      \item Useful for category cleanup or bulk removal.
      \item Returns \texttt{deletedCount}.
      \item Must be used carefully to avoid mass deletion.
    \end{itemize}
  \end{column}

  \begin{column}{0.60\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# Delete all Accessories
db.produk.deleteMany({ kategori: "Aksesoris" })

# Delete all out-of-stock products
db.produk.deleteMany({ stok: { $lte: 0 } })

{
  acknowledged: true,
  deletedCount: 3
}

# WARNING: delete everything!
db.produk.deleteMany({})

# Drop entire collection
db.produk.drop()
\end{lstlisting}
  \end{column}

\end{columns}
\end{frame}

\begin{frame}[fragile]{Delete Many in Python}
\vspace{20pt}
\begin{columns}[T]

  \begin{column}{0.40\textwidth}
    \begin{itemize}
      \item Python provides \texttt{delete_many()} for multi-deletes.
      \item Returns number of affected documents.
      \item Filters must be specific to prevent mass deletion.
      \item Suitable for cleaning categories or expired items.
    \end{itemize}
  \end{column}

  \begin{column}{0.60\textwidth}
\begin{lstlisting}[style=PythonStyle,
basicstyle=\ttfamily\scriptsize]
from pymongo import MongoClient

client = MongoClient()
db = client["toko_online"]
produk = db["produk"]

# Delete Accessories
hasil = produk.delete_many({"kategori": "Aksesoris"})
print("Terhapus:", hasil.deleted_count)

# Delete out-of-stock products
hasil2 = produk.delete_many({"stok": {"$lte": 0}})
print("Terhapus:", hasil2.deleted_count)
\end{lstlisting}
  \end{column}

\end{columns}
\end{frame}


\begin{frame}{SQL vs NoSQL Modeling — Concepts}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.50\textwidth}
\begin{itemize}
  \item SQL uses strict tables, schemas, and normalization.
  \item ACID (Atomicity, Consistency, Isolation, Durability) compliance ensures strong consistency.
  \item JOIN operations are common for combining related data.
  \item Structure is rigid and requires migrations for changes.
\end{itemize}
\end{column}

\begin{column}{0.50\textwidth}
\begin{itemize}
  \item MongoDB uses flexible BSON (Binary JSON) documents.
  \item Favors embedding related data in one document.
  \item Designed around application access patterns.
  \item Schema can evolve without altering existing documents.
\end{itemize}
\end{column}

\end{columns}
\end{frame}

\begin{frame}[fragile]{SQL vs NoSQL Modeling — Examples}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.50\textwidth}
\textbf{SQL Relational Model}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
TABLE customers:
  id, name, email

TABLE orders:
  id, customer_id, order_date

TABLE order_items:
  id, order_id, product_id,
  quantity, price
\end{lstlisting}

\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
SELECT *
FROM orders
JOIN customers
ON customers.id = orders.customer_id
JOIN order_items
ON order_items.order_id = orders.id
WHERE orders.id = 123;
\end{lstlisting}
\end{column}

\begin{column}{0.50\textwidth}
\textbf{MongoDB Document Model}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
{
  _id: ObjectId(...),
  customer: {
    id: 10,
    name: "Andi",
    email: "andi@example.com"
  },
  order_date: ISODate(...),
  items: [
    { product_id: 2001,
      name: "Keyboard Mechanical",
      quantity: 1, price: 750000 },
    { product_id: 3010,
      name: "Laptop Pro X",
      quantity: 1, price: 18500000 }
  ]
}
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}

\begin{frame}{Modeling SQL vs NoSQL: Practical Differences}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.50\textwidth}
\begin{itemize}
  \item MongoDB reduces reading cost by embedding related data.
  \item Flexible schema supports fast iteration and prototyping.
  \item Useful when data is typically retrieved as a whole.
  \item Document structure often matches application objects.
\end{itemize}
\end{column}

\begin{column}{0.50\textwidth}
\begin{itemize}
  \item Designers must consider document size and update frequency.
  \item Heavy updates may favor referencing over embedding.
  \item Global reusable data may be stored separately.
  \item Balance flexibility with long-term data consistency.
\end{itemize}
\end{column}

\end{columns}
\end{frame}

\begin{frame}{Embedded vs Referenced Data — Overview}
\vspace{20pt}
\begin{itemize}
  \item MongoDB supports two main modeling styles:
        \textbf{Embedded Documents} and \textbf{Referenced Documents}.
  \item No rigid foreign-key rules like SQL; modeling follows access patterns.
  \item Embedded: store related data together for fast reads.
  \item Referenced: separate documents when data is reused or large.
  \item Choice depends on document size, update frequency, and consistency needs.
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Embedded Data — Example Document}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.35\textwidth}
\begin{itemize}
  \item Ideal when related data is always accessed together.
  \item Efficient: one \texttt{find()} retrieves full details.
  \item Suitable for transactional or historical data.
  \item Represents real-world entities in one document.
\end{itemize}
\end{column}

\begin{column}{0.6\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
{
  _id: ObjectId("67ac45ff9c1eab0012aa401"),
  customer_id: 10,
  order_date: ISODate("2025-01-15"),
  items: [
    { product_id: 2001, name: "Keyboard Mechanical",
      quantity: 1, price: 750000 },
    { product_id: 3010, name: "Headset Gaming",
      quantity: 2, price: 850000 }
  ],
  shipping: {
    address: "Jl. Mawar No. 12",
    city: "Tangerang",
    courier: "JNE"
  }
}
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}


\begin{frame}[fragile]{Referenced Data — Concept \& Example}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.35\textwidth}
\begin{itemize}
  \item Use when data is reused across many documents.
  \item Ensures global updates apply everywhere.
  \item Prevents oversized documents.
  \item Requires multiple queries or manual populate.
\end{itemize}
\end{column}

\begin{column}{0.6\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# customers collection
{
  _id: 10,
  name: "Andi",
  email: "andi@example.com"
}

# orders collection
{
  _id: ObjectId("67ac467e1a993001ba04f102"),
  customer_id: 10,
  order_date: ISODate("2025-01-17")
}
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}


\begin{frame}[fragile]{Referenced Data — Querying}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.50\textwidth}
\textbf{mongosh}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
order = db.orders.findOne({
  _id: ObjectId("67ac467e1a993001ba04f102")
})

customer = db.customers.findOne({
  _id: order.customer_id
})

order
customer
\end{lstlisting}
\end{column}

\begin{column}{0.50\textwidth}
\textbf{Python}
\begin{lstlisting}[style=PythonStyle,
basicstyle=\ttfamily\scriptsize]
from pymongo import MongoClient
from bson import ObjectId

client = MongoClient()
db = client["toko_online"]

order = db.orders.find_one({
    "_id": ObjectId("67ac467e1a993001ba04f102")
})

customer = db.customers.find_one({
    "_id": order["customer_id"]
})

print("Order:", order)
print("Customer:", customer)
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}

\begin{frame}[fragile]{One-to-One Relationship (Embedded)}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.45\textwidth}
\begin{itemize}
  \item MongoDB supports relationships even without foreign keys.
  \item Relationships are represented using embedded or referenced data.
  \item One-to-one fits well with embedded documents.
  \item Ideal when both pieces of data always move together.
  \item Common example: user profile stored inside the user document.
\end{itemize}
\end{column}

\begin{column}{0.55\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
{
  _id: 101,
  name: "Andi",
  email: "andi@example.com",
  profile: {
    birth_date: ISODate("1999-03-12"),
    phone: "08123456789"
  }
}
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}

\begin{frame}[fragile]{One-to-One Relationship (Referenced)}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.45\textwidth}
\begin{itemize}
  \item Referenced modeling is used when data is too large to embed.
  \item Suitable for large profile data, images, or rarely accessed metadata.
  \item The main document stores only a \texttt{profile\_id}.
  \item The actual profile data lives in a separate collection.
  \item Similar to relational modeling but without explicit constraints.
\end{itemize}
\end{column}

\begin{column}{0.55\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# profiles
{
  _id: ObjectId("67ad88aa1f1100abcde00123"),
  birth_date: ISODate("1999-03-12"),
  phone: "08123456789",
  photo_url: "https://cdn.example.com/profile/andi.jpg",
  bio: "Technology and photography enthusiast."
}

# users
{
  _id: 101,
  name: "Andi",
  email: "andi@example.com",
  profile_id: ObjectId("67ad88aa1f1100abcde00123")
}
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}

\begin{frame}[fragile]{One-to-Many in MongoDB (Embedded)}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.45\textwidth}
\begin{itemize}
  \item One-to-many is the most common relationship in applications.
  \item MongoDB can model it using embedded lists or references.
  \item Embedded is ideal when the number of child items is small.
  \item Suitable for delivery addresses, tags, or small comment lists.
  \item Efficient because all related data is inside a single document.
\end{itemize}
\end{column}

\begin{column}{0.55\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
{
  _id: 201,
  title: "Belajar MongoDB",
  tags: ["database", "nosql", "mongodb"],
  comments: [
    { user: "Dina",
      text: "Sangat membantu!",
      date: ISODate("2025-01-11") },
    { user: "Rafi",
      text: "Terima kasih!",
      date: ISODate("2025-01-12") }
  ]
}
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}


\begin{frame}[fragile]{One-to-Many in MongoDB (Referenced)}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.45\textwidth}
\begin{itemize}
  \item Use references when child elements may grow very large.
  \item Embedding thousands of items may exceed MongoDB's document limit.
  \item Each child (e.g., review) is stored in its own collection.
  \item The parent document stores only an identifier like \texttt{product\_id}.
  \item Suitable for products with large and unpredictable review counts.
\end{itemize}
\end{column}

\begin{column}{0.55\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# products collection
{
  _id: 3001,
  name: "Laptop Pro X"
}

# reviews collection
{
  _id: ObjectId("67ac89ff2f1ab00200fa1123"),
  product_id: 3001,
  rating: 5,
  comment: "Luar biasa!"
}

{
  _id: ObjectId("67ac89ff2f1ab00200fa1124"),
  product_id: 3001,
  rating: 4,
  comment: "Performa cepat dan stabil."
}
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}

\begin{frame}[fragile]{Many-to-Many Relationship in MongoDB}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.58\textwidth}
\begin{itemize}
  \item Many-to-many occurs when both entities relate to multiple items.
  \item Common examples: students–courses, films–actors.
  \item Implemented using two-way references; embedding is not suitable.
  \item Each collection stores references to the other.
  \item Applications combine data using two queries or aggregation.
  \item A join-like intermediary collection may be used when the relationship has extra attributes (e.g., grades, enrollment date).
\end{itemize}
\end{column}

\begin{column}{0.37\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# students collection
{
  _id: 501,
  name: "Dina",
  courses: [101, 102]
}

# courses collection
{
  _id: 101,
  title: "Basis Data Lanjut",
  students: [501, 502, 503]
}
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}

\section{Schema Design Best Practices}

\begin{frame}[fragile]{Schema Best Practices: Application Focus}
\vspace{15pt}
\begin{columns}[T]

\begin{column}{0.55\textwidth}
\begin{itemize}
  \item Schema design is driven by application access patterns.
  \item Goal: optimize common read/write operations, not avoid duplicates.
  \item Documents should represent logical, meaningful application objects.
  \item Embed when data is usually accessed together and remains small.
  \item Reference when data may grow large or is shared across entities.
  \item A common beginner mistake: over-normalizing like SQL and causing excessive queries.
\end{itemize}
\end{column}

\begin{column}{0.4\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# Poor design: oversized embedded data
{
  _id: 9001,
  name: "Popular Product",
  reviews: [
    { user: "Andi", rating: 5, text: "Great!" },
    { user: "Dina", rating: 4, text: "Nice enough" },
    ...
    # hundreds or thousands more reviews
  ]
}
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}

\begin{frame}[fragile]{Schema Best Practices: Growth \& Indexing}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.55\textwidth}
\begin{itemize}
  \item Max MongoDB doc size: 16 MB.
  \item Large documents are slows on
        rewriting the whole document on update -- should not be fully embedded.
  \item If the application reads combined data often, embedding is beneficial.
  \item If the application frequently reads only subsets, separating data improves performance.
  \item Indexing is essential for fast queries.
  \item Fields used frequently for filtering and sorting should be indexed.
\end{itemize}
\end{column}

\begin{column}{0.4\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# Useful indexes
db.produk.createIndex({ kategori: 1 })

# Composite index for category + price
db.produk.createIndex({ kategori: 1, harga: -1 })
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}


\begin{frame}[fragile]{Best Practices: Consistency \& Evolution}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.55\textwidth}
\begin{itemize}
  \item Best performance
        occurs when operations occur within a single document -- avoid multi-document updates unless necessary.
  \item If parts of the data are always updated together,
        keep them in the same document.
  \item Example: a shopping cart should be a single document to ensure atomic updates.
  \item MongoDB schema should evolve with the application—avoid overly rigid structures.
  \item Flexible design fits agile development where requirements change often.
\end{itemize}
\end{column}

\begin{column}{0.4\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
# Good schema for a shopping cart
{
  _id: 7001,
  user_id: 31,
  items: [
    { product_id: 1001, qty: 2, price: 750000 },
    { product_id: 1002, qty: 1, price: 250000 }
  ],
  updated_at: ISODate("2025-01-20T13:25:00Z")
}
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}

\section{Document Structure \& Denormalization}

\begin{frame}[fragile]{Doc Structure \& Controlled Denormalization}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.47\textwidth}
\begin{itemize}
  \item MongoDB documents use BSON, allowing flexible nested structures.
  \item A document should stand as a complete logical unit.
  \item Controlled denormalization embeds data frequently accessed together.
  \item This differs from SQL normalization, which splits data into tables.
  \item Embedding avoids extra queries and improves read performance.
  \item Ideal when secondary data is stable and tightly coupled.
\end{itemize}
\end{column}

\begin{column}{0.53\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
{
  _id: ObjectId("67acddc91eaa09001f441122"),
  title: "Memahami MongoDB...",
  author: { id: 501, name: "Dina",
            email: "dina@example.com" },
  tags: ["database","nosql","mongodb"],
  comments: [
    { user: "Andi",
      text: "Penjelasannya jelas!",
      date: ISODate("2025-01-10") },
    { user: "Rafi",
      text: "Membantu sekali!",
      date: ISODate("2025-01-12") }
  ],
  created_at: ISODate("2025-01-09")
}
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}

\begin{frame}[fragile]{Denormalization Trade-offs \& Growth Limits}
\vspace{20pt}
\begin{columns}[T]

\begin{column}{0.47\textwidth}
\begin{itemize}
  \item Denormalization is not always ideal.
  \item Large or fast-growing arrays can cause document bloat.
  \item MongoDB documents have a 16 MB size limit.
  \item Large documents slow writes—MongoDB rewrites the entire document.
  \item Logs, histories, and activity streams should be split into collections.
  \item Separating data improves scalability and update efficiency.
\end{itemize}
\end{column}

\begin{column}{0.53\textwidth}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily\scriptsize]
{
  _id: 4001,
  user_id: 21,
  activities: [
    { type: "login",
      time: ISODate("2025-01-01T09:00Z") },
    { type: "view_page",
      time: ISODate("2025-01-01T09:01Z") },
    { type: "click",
      time: ISODate("2025-01-01T09:02Z") },
    ... # thousands more entries
  ]
}
\end{lstlisting}
\end{column}

\end{columns}
\end{frame}

\begin{frame}{Summary}
\vspace{20pt}

\begin{itemize}
  \item Introducing MongoDB’s CRUD operations:
        \textbf{Create}, \textbf{Read}, \textbf{Update}, \textbf{Delete}.
  \item Create uses \texttt{insertOne()} / \texttt{insertMany()}, both in
        \texttt{mongosh} and Python (\texttt{pymongo}).
  \item Read uses \texttt{find()} with projection, sorting, and pagination
        (\texttt{skip()}, \texttt{limit()}).
  \item Update relies on \texttt{updateOne()} / \texttt{updateMany()} with
        operators such as \texttt{\$set}, \texttt{\$inc}, \texttt{\$push}.
  \item Delete uses \texttt{deleteOne()} / \texttt{deleteMany()}, emphasizing
        careful filtering due to permanent deletion.
  \item You also explored data modeling principles: embedded vs referenced
        documents, one-to-one, one-to-many, many-to-many, and schema design
        best practices.
  \item Effective MongoDB schema design aligns with application access
        patterns, document size limits, update frequency, and consistency needs.
\end{itemize}

\end{frame}

\end{document}